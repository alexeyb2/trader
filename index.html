<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>График с выбором полей</title>
    <style>
        html, body {
            padding: 0;
            margin: 0;
            font-family: Arial, sans-serif;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        #controlPanel {
            position: absolute;
            z-index: 10;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            max-width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            font-size: 14px;
        }
        #controlPanel h3 {
            margin-top: 0;
            text-align: center;
        }
        .field-group {
            margin-bottom: 10px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        .field-group label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }
        .field-group input[type="checkbox"] {
            margin-right: 8px;
        }
        #forWrite {
            position: absolute;
            z-index: 5;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controlPanel">
        <h3>Отображаемые данные</h3>
        <div class="field-group">
            <label><input type="checkbox" id="showIndicators" checked> Индикаторы (bb, sar)</label>
            <label><input type="checkbox" id="showLevels" checked> Уровни (levels)</label>
            <label><input type="checkbox" id="showTargets" checked> Цели (targets)</label>
            <label><input type="checkbox" id="showWave" checked> Волны (wave)</label>
            <label><input type="checkbox" id="showDirectionBar" checked> Направление/бар (direction_and_bar)</label>
            <label><input type="checkbox" id="showMoney" checked> Деньги (money)</label>
            <label><input type="checkbox" id="showBabylons" checked> Babylon (babylons)</label>
            <label><input type="checkbox" id="showTickerData" checked> Ticker data</label>
            <label><input type="checkbox" id="showTickerChanges" checked> Ticker changes</label>
        </div>
        <button id="reloadBtn">Обновить данные</button>
    </div>
    <div id="forWrite">Загрузка...</div>
    <div id="loading" style="display: none;">Загрузка данных...</div>

    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ccxt@4.4.86/dist/ccxt.browser.min.js"></script>
    <script>
        // --- Конфигурация ---
        const API_BASE = 'http://77.91.68.42:8000'; // Замените на ваш адрес (лучше HTTPS)
        const urlParams = new URLSearchParams(window.location.search);
        const symbol = urlParams.get('n') || 'BTC';
        const tf = urlParams.get('tf') || '1m';

        // --- Глобальные переменные ---
        let chart, mainSeries;
        let tickSize = 0.00000001;
        let priceDecimals = 8;
        let linesData = [];          // все созданные линии (для обновления расстояния)
        let wavesSeries = {};         // все созданные серии волн
        let markers = [];             // маркеры для установки
        let currentData = null;       // последние загруженные данные

        // DOM-элементы
        const container = document.getElementById('container');
        const forWriteDiv = document.getElementById('forWrite');
        const loadingDiv = document.getElementById('loading');
        const reloadBtn = document.getElementById('reloadBtn');

        // Чекбоксы
        const showIndicators = document.getElementById('showIndicators');
        const showLevels = document.getElementById('showLevels');
        const showTargets = document.getElementById('showTargets');
        const showWave = document.getElementById('showWave');
        const showDirectionBar = document.getElementById('showDirectionBar');
        const showMoney = document.getElementById('showMoney');
        const showBabylons = document.getElementById('showBabylons');
        const showTickerData = document.getElementById('showTickerData');
        const showTickerChanges = document.getElementById('showTickerChanges');

        // --- Утилиты ---
        function showError(msg) {
            forWriteDiv.innerText = 'Ошибка: ' + msg;
            console.error(msg);
        }

        // --- Функции для работы с графиком ---

        // Инициализация графика
        function initChart() {
            if (chart) chart.remove();
            chart = LightweightCharts.createChart(container, {
                localization: {
                    priceFormatter: p => p.toFixed(priceDecimals)
                },
                timeScale: {
                    timeVisible: true,
                    barSpacing: 10
                }
            });
            mainSeries = chart.addCandlestickSeries();
            linesData = [];
            wavesSeries = {};
        }

        // Добавление горизонтальной линии
        function addLine(price, settings) {
            if (!mainSeries) return;
            const line = mainSeries.createPriceLine({
                price: price,
                color: settings.color || 'red',
                lineWidth: settings.lineWidth || 1,
                lineStyle: settings.lineStyle || 0,
                title: settings.title || '',
                axisLabelVisible: true
            });
            linesData.push({
                line: line,
                originalTitle: settings.title || '',
                price: price
            });
            return line;
        }

        // Добавление волны (отдельная серия)
        function addWave(name, points, settings) {
            if (!chart || !points.length) return;
            // Если серия уже существует, удаляем её
            if (wavesSeries[name]) {
                chart.removeSeries(wavesSeries[name]);
            }
            const waveSeries = chart.addLineSeries({
                color: settings.color || 'blue',
                lineWidth: settings.lineWidth || 1,
                title: settings.title || name
            });
            const data = points.map(p => ({ time: p[0], value: p[1] }));
            waveSeries.setData(data);
            wavesSeries[name] = waveSeries;
        }

        // Установка маркеров
        function setMarkers(markersList) {
            if (!mainSeries) return;
            mainSeries.setMarkers(markersList.map(m => ({
                time: m.time,
                position: m.position || 'inBar',
                color: m.color || 'red',
                shape: m.shape || 'circle',
                text: m.text || ''
            })));
        }

        // Очистка всех линий и волн
        function clearAll() {
            if (mainSeries) {
                // Удаляем ценовые линии (в lightweight-charts 4.2.3 нет прямого метода удалить все сразу)
                // Просто создадим новую основную серию
                chart.removeSeries(mainSeries);
                mainSeries = chart.addCandlestickSeries();
                linesData = [];
            }
            // Удаляем волны
            Object.values(wavesSeries).forEach(s => chart.removeSeries(s));
            wavesSeries = {};
        }

        // --- Функции отрисовки различных полей (без изменений, как в предыдущих версиях) ---

        function drawIndicators(indicators) {
            if (!indicators) return;
            const names = ['bb_lower', 'bb_middle', 'bb_upper', 'sar'];
            const colors = ['red', 'green', 'blue', 'yellow', '#fde910'];
            let lineWidth = 1;
            for (const [tf, tfData] of Object.entries(indicators)) {
                names.forEach((name, idx) => {
                    if (tfData[name] && tfData[name][1] !== undefined) {
                        const price = tfData[name][1];
                        const title = `${tf}_${name}`;
                        addLine(price, {
                            title: title,
                            color: colors[idx],
                            lineWidth: lineWidth,
                            lineStyle: 1
                        });
                        if (name === 'sar' && tfData[name][0] !== undefined) {
                            addLine(tfData[name][0], {
                                title: title + '_before',
                                color: colors[4],
                                lineWidth: lineWidth,
                                lineStyle: 1
                            });
                        }
                    }
                });
                lineWidth++;
            }
        }

        function drawLevels(levels, direction, defaultColor) {
            if (!Array.isArray(levels)) return;
            levels.forEach(level => {
                if (level.price) {
                    addLine(level.price, {
                        title: `${level.tf || ''} ${level.by || ''} ${direction ? 'верх' : 'низ'}`,
                        color: defaultColor,
                        lineWidth: 1,
                        lineStyle: 0
                    });
                }
            });
        }

        function drawTargets(targets) {
            // targets может быть массивом объектов с price, tf, by, direction
            if (!Array.isArray(targets)) return;
            targets.forEach(target => {
                if (target.price) {
                    addLine(target.price, {
                        title: `${target.tf || ''} ${target.by || ''} цель`,
                        color: 'purple',
                        lineWidth: 1,
                        lineStyle: 2
                    });
                }
            });
        }

        function drawWave(waveData) {
            if (!waveData || !waveData['..'] || !waveData[':']) return;
            const waveSettings = waveData[':'];
            const wavePoints = waveData['..'];
            
            function extractPoints(arr) {
                return arr
                    .filter(item => item && item['.'])
                    .map(item => item['.'])
                    .sort((a, b) => a[0] - b[0]);
            }

            if (wavePoints.limits && Array.isArray(wavePoints.limits)) {
                const points = extractPoints(wavePoints.limits);
                const settings = waveSettings.limits || {};
                const color = settings.direction === 1 ? 'green' : 'red';
                addWave('limits', points, { color: color, lineWidth: 2, title: 'limits' });
            }
            if (wavePoints.self && Array.isArray(wavePoints.self)) {
                const points = extractPoints(wavePoints.self);
                const settings = waveSettings.self || {};
                const color = settings.direction === 1 ? 'blue' : 'orange';
                addWave('self', points, { color: color, lineWidth: 1, title: 'self' });
            }

            // Маркеры
            const markersList = [];
            if (wavePoints.limits) {
                wavePoints.limits.forEach(item => {
                    if (item['.']) {
                        const time = item['.'][0];
                        const dir = item[':']?.direction;
                        markersList.push({
                            time: time,
                            position: 'belowBar',
                            color: dir === 1 ? 'green' : 'red',
                            shape: dir === 1 ? 'arrowUp' : 'arrowDown',
                            text: `L${dir}`
                        });
                    }
                });
            }
            if (wavePoints.self) {
                wavePoints.self.forEach(item => {
                    if (item['.']) {
                        const time = item['.'][0];
                        const dir = item[':']?.direction;
                        markersList.push({
                            time: time,
                            position: 'aboveBar',
                            color: dir === 1 ? 'blue' : 'orange',
                            shape: 'circle',
                            text: `S${dir}`
                        });
                    }
                });
            }
            if (markersList.length) setMarkers(markersList);
        }

        function drawDirectionBar(dirBar) {
            // Поле direction_and_bar может содержать направление и бар
            if (!dirBar) return;
            if (dirBar.bar) {
                // Можно добавить маркер на бар
                const barTime = dirBar.bar[0] / 1000; // предположительно мс -> сек
                addMarker(barTime, {
                    position: 'inBar',
                    color: 'orange',
                    shape: 'circle',
                    text: 'dir'
                });
            }
        }

        function drawMoney(money) {
            // money – вероятно, объект с данными о деньгах/позициях
            if (!money || !money.position) return;
            const pos = money.position;
            if (pos.entry_price) addLine(pos.entry_price, { title: 'Entry', color: '#00ff00', lineWidth: 2 });
            if (pos.stop_loss) addLine(pos.stop_loss, { title: 'SL', color: '#ff0000', lineWidth: 2 });
            if (pos.take_profit) addLine(pos.take_profit, { title: 'TP', color: '#0000ff', lineWidth: 2 });
        }

        function drawBabylons(babylons) {
            // babylons – вероятно, данные о пузырях или индикаторах
            if (!babylons) return;
            // Пример: если есть price, отрисовать линию
            if (babylons.price) addLine(babylons.price, { title: 'Babylon', color: '#ff66ff' });
        }

        function drawTickerData(ticker) {
            // ticker_data – тикер с полями bid, ask, last и т.д.
            if (!ticker) return;
            if (ticker.bid) addLine(ticker.bid, { title: 'Bid', color: '#00ff00', lineStyle: 2 });
            if (ticker.ask) addLine(ticker.ask, { title: 'Ask', color: '#ff0000', lineStyle: 2 });
            if (ticker.last) addLine(ticker.last, { title: 'Last', color: '#ffff00', lineWidth: 2 });
        }

        function drawTickerChanges(changes) {
            // ticker_changes – изменения
            if (!changes) return;
            // Можно добавить маркер или линию
        }

        // --- Обновление заголовков линий с расстоянием ---
        function updateLineTitles(currentPrice) {
            linesData.forEach(item => {
                const distance = (item.price - currentPrice) / tickSize;
                const sign = distance >= 0 ? '+' : '';
                item.line.applyOptions({
                    title: `${item.originalTitle} (${sign}${Math.round(distance)})`
                });
            });
        }

        // --- Загрузка данных с сервера ---
        async function loadSymbolData() {
            loadingDiv.style.display = 'block';
            try {
                // Формируем список полей, которые нужно получить
                const fields = [];
                if (showIndicators.checked) fields.push('indicators_data');
                if (showLevels.checked) fields.push('levels');
                if (showTargets.checked) fields.push('targets');
                if (showWave.checked) fields.push('wave');
                if (showDirectionBar.checked) fields.push('direction_and_bar');
                if (showMoney.checked) fields.push('money');
                if (showBabylons.checked) fields.push('babylons');
                if (showTickerData.checked) fields.push('ticker_data');
                if (showTickerChanges.checked) fields.push('ticker_changes');
                
                // Запрос к публичному эндпоинту с параметром fields
                const url = new URL(`${API_BASE}/public/symbol/${symbol}`);
                if (fields.length) url.searchParams.append('fields', fields.join(','));
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                currentData = data;

                // Устанавливаем tickSize из info, если есть
                if (data.info && data.info.tick_size) {
                    tickSize = data.info.tick_size;
                    priceDecimals = Math.max(0, Math.round(-Math.log10(tickSize)));
                }

                // Отрисовываем выбранные поля
                clearAll(); // очищаем старые линии и волны
                
                if (showIndicators.checked && data.indicators_data) drawIndicators(data.indicators_data);
                if (showLevels.checked && data.levels) {
                    if (data.levels[0]) drawLevels(data.levels[0], 0, 'blue');
                    if (data.levels[1]) drawLevels(data.levels[1], 1, 'red');
                }
                if (showTargets.checked && data.targets) drawTargets(data.targets);
                if (showWave.checked && data.wave) drawWave(data.wave);
                if (showDirectionBar.checked && data.direction_and_bar) drawDirectionBar(data.direction_and_bar);
                if (showMoney.checked && data.money) drawMoney(data.money);
                if (showBabylons.checked && data.babylons) drawBabylons(data.babylons);
                if (showTickerData.checked && data.ticker_data) drawTickerData(data.ticker_data);
                if (showTickerChanges.checked && data.ticker_changes) drawTickerChanges(data.ticker_changes);

                forWriteDiv.innerText = `${symbol} ${tf} tick: ${tickSize}`;
            } catch (e) {
                showError('Не удалось загрузить данные: ' + e.message);
            } finally {
                loadingDiv.style.display = 'none';
            }
        }

        // --- Запуск обновления свечей через CCXT ---
        async function startPriceUpdates() {
            const exchange = new ccxt.bybit({ enableRateLimit: true });
            const symbolPair = symbol + '/USDT:USDT';
            while (true) {
                try {
                    const ohlcv = await exchange.fetchOHLCV(symbolPair, tf, undefined, 200);
                    const data = ohlcv.map(([t, o, h, l, c]) => ({ time: t / 1000, open: o, high: h, low: l, close: c }));
                    mainSeries.setData(data);
                    if (data.length > 0) {
                        updateLineTitles(data[data.length - 1].close);
                    }
                } catch (e) {
                    console.error('CCXT error:', e);
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        // --- Перезагрузка данных и перерисовка ---
        async function reloadData() {
            await loadSymbolData();
        }

        // --- Инициализация ---
        async function main() {
            initChart();
            await loadSymbolData();
            startPriceUpdates();

            // Обработчик кнопки обновления
            reloadBtn.addEventListener('click', reloadData);

            // Обработчики чекбоксов (можно перезагружать при изменении)
            const checkboxes = [
                showIndicators, showLevels, showTargets, showWave,
                showDirectionBar, showMoney, showBabylons,
                showTickerData, showTickerChanges
            ];
            checkboxes.forEach(cb => {
                cb.addEventListener('change', reloadData);
            });
        }

        main();
    </script>
</body>
</html>
